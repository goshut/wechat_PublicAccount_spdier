<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《源码探秘 CPython》5 对象是如何被调用的</title>
    <link rel="stylesheet" href="../edit.css">
</head>

<body class='background'>
<div class="wx_temp">
    <div id="img-content" class="rich_media_wrp">
          
          <h1 class="rich_media_title " id="activity-name">
            
《源码探秘 CPython》5. 对象是如何被调用的
          </h1>
          <div id="meta_content" class="rich_media_meta_list">
                                      <span id="copyright_logo" class="wx_tap_link js_wx_tap_highlight rich_media_meta icon_appmsg_tag appmsg_title_tag weui-wa-hotarea">原创</span>
                                                      <span class="rich_media_meta rich_media_meta_text">
                                      古明地觉
                                  </span>
                                      
                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt">
              <a href="javascript:void(0);" class="wx_tap_link js_wx_tap_highlight weui-wa-hotarea" id="js_name">
                古明地觉的编程教室              </a>
              <div id="js_profile_qrcode" aria-hidden="true" class="profile_container" style="display:none;">
                <div class="profile_inner">
                  <strong class="profile_nickname">古明地觉的编程教室</strong>
                  <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                  <p class="profile_meta">
                  <label class="profile_meta_label">微信号</label>
                  <span class="profile_meta_value">unwind_exception</span>
                  </p>

                  <p class="profile_meta">
                  <label class="profile_meta_label">功能介绍</label>
                  <span class="profile_meta_value">Python、Rust 程序猿，你感兴趣的内容我都会写，点个关注吧(#^.^#)</span>
                  </p>
                </div>
                <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                  <i class="profile_arrow arrow_out"></i>
                  <i class="profile_arrow arrow_in"></i>
                </span>
              </div>
            </span>
            <em id="publish_time" class="rich_media_meta rich_media_meta_text"></em>
            <em id="js_ip_wording_wrp" class="rich_media_meta rich_media_meta_text" role="option" style="display: none;">发表于<span id="js_ip_wording"></span></em>

          </div>

          
                                                                              <div id="js_tags" class="article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card" data-len="1" role="link" tabindex="0" aria-labelledby="js_article-tag-card__left js_a11y_comma js_article-tag-card__right">
                          
                                                <span aria-hidden="true" id="js_article-tag-card__left" class="article-tag-card__left">
                    <span class="article-tag-card__title">收录于合集</span>
                    <span class="article-tag__item-wrp no-active js_tag" data-url="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3NTczMDU2Mg==&amp;action=getalbum&amp;album_id=2206970536067497985#wechat_redirect" data-tag_id="" data-album_id="2206970536067497985" data-tag_source="4">
                      <span class="article-tag__item">#CPython源码探秘</span>
                    </span>
                  </span>
                  <span aria-hidden="true" id="js_article-tag-card__right" class="article-tag-card__right">91个</span>
                                                    </div>

          
                    
                                        

          
                    

          
                              
                                        
                    
                    
          

          
          
                                                  <div class="rich_media_content js_underline_content              " id="js_content"><p style="text-align: center;"><strong><span style="font-size: 24px;color: rgb(217, 33, 66);">楔子</span></strong><br></p><p><br></p><p>在上一篇文章中，我们知道了对象是如何被创建的，主要有两种方式，一种是通过<span style="color: rgb(0, 82, 255);"><strong>Python/C API</strong></span>，另一种是通过<span style="color: rgb(0, 82, 255);"><strong>调用类型对象</strong></span>。对于内置类型的实例对象而言，这两种方式都是支持的，比如列表，我们即可以通过<span style="color: rgb(0, 82, 255);"><strong>[]</strong></span>创建，也可以通过<span style="color: rgb(0, 82, 255);"><strong>list()</strong></span>，前者是<span style="color: rgb(0, 82, 255);"><strong>Python/C API</strong></span>，后者是<strong style="color: rgb(0, 82, 255);white-space: normal;">调用类型对象</strong>。</p><p><br></p><p>但对于自定义类的实例对象而言，我们只能通过<strong style="white-space: normal;color: rgb(0, 82, 255);">调用类型对象</strong>的方式来创建。而一个对象如果可以被调用，那么这个对象就是<span style="color: rgb(0, 82, 255);"><strong>callable</strong></span>，否则就不是<span style="color: rgb(0, 82, 255);"><strong>callable</strong></span>。</p><p><br></p><p>而决定一个对象是不是<span style="color: rgb(0, 82, 255);"><strong>callable</strong></span>，就取决于其对应的类型对象中是否定义了某个方法。如果从 Python 的角度看的话，这个方法就是 <span style="color: rgb(0, 82, 255);"><strong>__call__</strong></span>，从解释器角度看的话，这个方法就是 <strong><span style="color: rgb(0, 82, 255);">tp_call</span></strong>。<br></p><p><br></p><p><br></p><p style="text-align: center;"><strong style="text-align: center;white-space: normal;"><span style="font-size: 24px;color: rgb(217, 33, 66);">从 Python 的角度看对象的调用</span></strong></p><p><br></p><p>调用 int、str、tuple 可以创建一个整数、字符串、元组，调用自定义的类也可以创建出相应的实例对象，说明类型对象是可调用的，也就是callable。那么这些类型对象（int、str、tuple、class等等）的类型对象（type）内部一定有 __call__ 方法。<br></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="bash"><code><span class="code-snippet_outer"><span class="code-snippet__comment"># int可以调用</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 那么它的类型对象、也就是元类(type), 内部一定有__call__方法</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">print</span>(hasattr(<span class="code-snippet__built_in">type</span>, <span class="code-snippet__string">"__call__"</span>))  <span class="code-snippet__comment"># True</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 而调用一个对象，等价于调用其类型对象的 __call__ 方法</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 所以 int(3.14)实际就等价于如下</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">print</span>(type.__call__(int, 3.14))  <span class="code-snippet__comment"># 3</span></span></code></pre></section><p>注意：这里描述的可能有一些绕，我们说 int、str、float 这些都是类型对象（简单来说就是<strong><span style="color: rgb(0, 82, 255);">类</span></strong>），而 123、"你好"、3.14 是其对应的实例对象，这些都没问题。但<span style="color: rgb(0, 82, 255);"><strong>type</strong></span>是不是类型对象，显然是的，虽然我们称呼它为<span style="color: rgb(0, 82, 255);"><strong>元类</strong></span>，但它也是类型对象，如果 print(type) 显示的也是一个类。</p><p><br></p><p>那么相对 type 而言，int、str、float 是不是又成了实例对象呢？因为它们的类型是 type。<br></p><p><br></p><p>所以 class 具有<span style="color: rgb(0, 82, 255);"><strong>二象性</strong></span>：<br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>如果站在实例对象（如：123、"satori"、[]、3.14）的角度上，它是类型对象</p></li><li><p>如果站在 type 的角度上，它是实例对象</p></li></ul><p><br></p><p>同理 type 的类型是也是 type，那么 type 既是 type 的类型对象，type 也是 type 的实例对象。虽然这里描述的会有一些绕，但应该不难理解，并且为了避免后续的描述出现歧义，这里我们做一个申明：<br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>整数、浮点数、字符串等等，我们称之为<span style="color: rgb(0, 82, 255);"><strong>实例对象</strong></span></p></li><li><p>int、float、str、dict，以及我们自定义的类，我们称之为<span style="color: rgb(0, 82, 255);"><strong>类型对象</strong></span></p></li><li><p>type 虽然也是类型对象，但我们称它为<span style="color: rgb(0, 82, 255);"><strong>元类</strong></span></p></li></ul><p><br></p><p>所以 type 的内部有 __call__ 方法，那么说明类型对象都是可调用的，因为调用类型对象就是调用 type 的 __call__ 方法。而实例对象能否调用就不一定了，这取决于它的类型对象中是否定义了 __call__ 方法，因为调用一个对象，本质上是执行其类型对象内部的 __call__ 方法。<br></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__class"><span class="code-snippet__keyword">class</span> <span class="code-snippet__title">A</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">pass</span></span></code><code><span class="code-snippet_outer">    </span></code><code><span class="code-snippet_outer">a = A()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 因为我们自定义的类 A 里面没有 __call__</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 所以 a 是不可以被调用的</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    a()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">except</span> Exception <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 告诉我们 A 的实例对象不可以被调用</span></span></code><code><span class="code-snippet_outer">    print(e)  <span class="code-snippet__comment"># 'A' object is not callable    </span></span></code><code><span class="code-snippet_outer">    </span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 如果我们给 A 设置了一个 __call__</span></span></code><code><span class="code-snippet_outer">type.__setattr__(A, <span class="code-snippet__string">"__call__"</span>, <span class="code-snippet__keyword">lambda</span> self: <span class="code-snippet__string">"这是__call__"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 发现可以调用了</span></span></code><code><span class="code-snippet_outer">print(a())  <span class="code-snippet__comment"># 这是__call__</span></span></code></pre></section><p>我们看到这就是动态语言的特性，即便在类创建完毕之后，依旧可以通过<span style="color: rgb(0, 82, 255);"><strong>type</strong></span>进行动态设置，而这在静态语言中是不支持的。所以<span style="color: rgb(0, 82, 255);"><strong>type</strong></span>是所有类的元类，它控制了我们自定义类的生成过程，<strong><span style="color: rgb(0, 82, 255);">type</span></strong>这个古老而又强大的类可以让我们玩出很多新花样。</p><p><br></p><p>但是对于内置的类，<span style="color: rgb(0, 82, 255);"><strong>type</strong></span>是不可以对其动态<span style="color: rgb(0, 82, 255);"><strong>增加</strong></span>、<span style="color: rgb(0, 82, 255);"><strong>删除</strong></span>或者<strong><span style="color: rgb(0, 82, 255);">修改</span></strong>属性的，因为内置的类在底层是静态定义好的。因为从源码中我们看到，这些内置的类、包括元类，它们都是<span style="color: rgb(0, 82, 255);"><strong>PyTypeObject</strong></span>对象，在底层已经被声明为全局变量了，或者说它们已经作为静态类存在了。所以<span style="color: rgb(0, 82, 255);"><strong>type</strong></span>虽然是所有类型对象的元类，但是只有在面对我们自定义的类，<span style="color: rgb(0, 82, 255);"><strong>type</strong></span>才具有增删改的能力。</p><p><br></p><p>而且在上一篇文章中我们也解释过，Python 的动态性是解释器将字节码翻译成 C 代码的时候动态赋予的，因此给类动态设置属性或方法只适用于动态类，也就是在 py 文件中使用 class 关键字定义的类。</p><p><br></p><p>而对于静态类、或者编写扩展模块时定义的扩展类（两者是等价的），它们在编译之后已经是指向 C 一级的数据结构了，不需要再被解释器解释了，因此解释器自然也就无法在它们身上动手脚，毕竟彪悍的人生不需要解释。</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li></ul><pre class="code-snippet__js" data-lang="swift"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    type.__setattr__(dict, <span class="code-snippet__string">"__call__"</span>, lambda <span class="code-snippet__keyword">self</span>: <span class="code-snippet__string">"这是__call__"</span>)</span></code><code><span class="code-snippet_outer">except <span class="code-snippet__type">Exception</span> <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__built_in">print</span>(e)  # can't <span class="code-snippet__keyword">set</span> attributes of built-<span class="code-snippet__keyword">in</span>/<span class="code-snippet__class"><span class="code-snippet__keyword">extension</span> <span class="code-snippet__title">type</span> '<span class="code-snippet__title">dict</span>'</span></span></code></pre></section><p>我们看到抛异常了，提示我们<span style="color: rgb(0, 82, 255);"><strong>不可以给内置/扩展类型dict设置属性</strong></span>，因为它们绕过了解释器解释执行这一步，所以其属性不能被动态设置。</p><p><br></p><p>同理其实例对象亦是如此，静态类的实例对象也不可以动态设置属性：</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__class"><span class="code-snippet__keyword">class</span> <span class="code-snippet__title">Girl</span>:</span> </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">pass</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">g = Girl()</span></code><code><span class="code-snippet_outer">g.name = <span class="code-snippet__string">"古明地觉"</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 实例对象我们也可以手动设置属性</span></span></code><code><span class="code-snippet_outer">print(g.name)  <span class="code-snippet__comment"># 古明地觉</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">lst = list()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    lst.name = <span class="code-snippet__string">"古明地觉"</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">except</span> Exception <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 但是内置类型的实例对象是不可以的</span></span></code><code><span class="code-snippet_outer">    print(e)  <span class="code-snippet__comment"># 'list' object has no attribute 'name'</span></span></code></pre></section><p>可能有人奇怪了，为什么列表不行呢？答案是内置类型的实例对象没有<span style="color: rgb(0, 82, 255);"><strong>__dict__</strong></span>属性字典，因为相关属性或方法底层已经定义好了，不可以动态添加。如果我们自定义类的时候，设置了<span style="color: rgb(0, 82, 255);"><strong>__slots__，</strong></span>那么效果和内置的类是相同的。</p><p><br></p><p>当然了，我们后面会介绍如何通过动态修改解释器来改变这一点，举个栗子，不是说静态类无法动态设置属性吗？下面我就来打自己脸：</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer">import gc</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    type.__setattr__(<span class="code-snippet__keyword">list</span>, <span class="code-snippet__string">"ping"</span>, <span class="code-snippet__string">"pong"</span>)</span></code><code><span class="code-snippet_outer">except TypeError <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">print</span>(e)  <span class="code-snippet__comment"># can't set attributes of built-in/extension type 'list'</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 我们看到无法设置，那么我们就来改变这一点</span></span></code><code><span class="code-snippet_outer">attrs = gc.get_referents(tuple.__dict__)[<span class="code-snippet__number">0</span>]</span></code><code><span class="code-snippet_outer">attrs[<span class="code-snippet__string">"ping"</span>] = <span class="code-snippet__string">"pong"</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">print</span>(().ping)  <span class="code-snippet__comment"># pong</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">attrs[<span class="code-snippet__string">"append"</span>] = lambda <span class="code-snippet__keyword">self</span>, item: <span class="code-snippet__keyword">self</span> + (item,)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">print</span>(</span></code><code><span class="code-snippet_outer">    ().append(<span class="code-snippet__number">1</span>).append(<span class="code-snippet__number">2</span>).append(<span class="code-snippet__number">3</span>)</span></code><code><span class="code-snippet_outer">)  <span class="code-snippet__comment"># (1, 2, 3)</span></span></code></pre></section><p>我脸肿了。好吧，其实这只是我们玩的一个小把戏，当我们介绍完整个 CPython 的时候，会来专门聊一聊如何动态修改解释器。比如：让元组变得可修改，让 Python 真正利用多核等等。</p><p><br></p><p><br></p><p style="text-align: center;"><strong style="text-align: center;white-space: normal;"><span style="font-size: 24px;color: rgb(217, 33, 66);">从解释器的角度看对象的调用</span></strong></p><p><br></p><p>我们以内置类型 float 为例，我们说创建一个 <span style="color: rgb(0, 82, 255);"><strong>PyFloatObject</strong></span>，可以通过<strong><span style="color: rgb(0, 82, 255);">3.14</span></strong>或者<span style="color: rgb(0, 82, 255);"><strong>float(3.14)</strong></span>的方式。前者使用<strong><span style="color: rgb(0, 82, 255);">Python/C API</span></strong>创建，3.14直接被解析为 C 一级数据结构，也就是<span style="color: rgb(0, 82, 255);"><strong>PyFloatObject实例</strong></span>；后者使用类型对象创建，通过对float进行一个调用、将3.14作为参数，最终也得到指向C一级数据结构<span style="color: rgb(0, 82, 255);"><strong>PyFloatObject实例</strong></span>。</p><p><br>Python/C API的创建方式我们已经很清晰了，就是根据值来推断在底层应该对应哪一种数据结构，然后直接创建即可。我们重点看一下通过类型调用来创建实例对象的方式。</p><p><br></p><p>如果一个对象可以被调用，它的类型对象中一定要有<span style="color: rgb(0, 82, 255);"><strong>tp_call</strong></span><strong><span style="color: rgb(64, 118, 0);">(更准确的说成员tp_call的值是一个函数指针，不可以是0)</span></strong>，而<span style="color: rgb(0, 82, 255);"><strong>PyFloat_Type</strong></span>是可以调用的，这就说明<span style="color: rgb(0, 82, 255);"><strong>PyType_Type</strong></span>内部的<span style="color: rgb(0, 82, 255);"><strong>tp_call</strong></span>是一个函数指针，这在Python的层面上我们已经验证过了，下面我们再来通过源码看一下。</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">//typeobject.c</span></span></code><code><span class="code-snippet_outer">PyTypeObject PyType_Type = {</span></code><code><span class="code-snippet_outer">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="code-snippet__number">0</span>)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__string">"type"</span>,                                     <span class="code-snippet__comment">/* tp_name */</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">sizeof</span>(PyHeapTypeObject),                   <span class="code-snippet__comment">/* tp_basicsize */</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">sizeof</span>(PyMemberDef),                        <span class="code-snippet__comment">/* tp_itemsize */</span></span></code><code><span class="code-snippet_outer">    (destructor)type_dealloc,                   <span class="code-snippet__comment">/* tp_dealloc */</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//...                                       /* tp_hash */</span></span></code><code><span class="code-snippet_outer">    (ternaryfunc)type_call,                     <span class="code-snippet__comment">/* tp_call */</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//...</span></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p>我们看到在实例化<span style="color: rgb(0, 82, 255);"><strong>PyType_Type</strong></span>的时候<span style="color: rgb(0, 82, 255);"><strong>PyTypeObject</strong></span>内部的成员<span style="color: rgb(0, 82, 255);"><strong>tp_call</strong></span>被设置成了<span style="color: rgb(0, 82, 255);"><strong>type_call</strong></span>。这是一个函数指针，当我们调用<span style="color: rgb(0, 82, 255);"><strong>PyFloat_Type</strong></span>的时候，会触发这个<span style="color: rgb(0, 82, 255);"><strong>type_call</strong></span>指向的函数。<strong style="color: rgb(0, 128, 0);font-family: 微软雅黑, PTSans, Arial, sans-serif;font-size: large;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"></strong></p><p><br></p><p>因此 float(3.14) 在C的层面上等价于：</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">(&amp;<span class="code-snippet__selector-tag">PyFloat_Type</span>) <span class="code-snippet__selector-tag">-</span>&gt; <span class="code-snippet__selector-tag">ob_type</span> <span class="code-snippet__selector-tag">-</span>&gt; <span class="code-snippet__selector-tag">tp_call</span>(&amp;<span class="code-snippet__selector-tag">PyFloat_Type</span>, <span class="code-snippet__selector-tag">args</span>, <span class="code-snippet__selector-tag">kwargs</span>);</span></code><code><span class="code-snippet_outer">// 即：</span></code><code><span class="code-snippet_outer">(&amp;<span class="code-snippet__selector-tag">PyType_Type</span>) <span class="code-snippet__selector-tag">-</span>&gt; <span class="code-snippet__selector-tag">tp_call</span>(&amp;<span class="code-snippet__selector-tag">PyFloat_Type</span>, <span class="code-snippet__selector-tag">args</span>, <span class="code-snippet__selector-tag">kwargs</span>);</span></code><code><span class="code-snippet_outer">// 而在创建 <span class="code-snippet__selector-tag">PyType_Type</span> 的时候，给 <span class="code-snippet__selector-tag">tp_call</span> 成员传递的是 <span class="code-snippet__selector-tag">type_call</span></span></code><code><span class="code-snippet_outer">// 因此最终相当于</span></code><code><span class="code-snippet_outer"><span class="code-snippet__selector-tag">type_call</span>(&amp;<span class="code-snippet__selector-tag">PyFloat_Type</span>, <span class="code-snippet__selector-tag">args</span>, <span class="code-snippet__selector-tag">kwargs</span>)</span></code></pre></section><p>如果用 Python 来演示这一过程的话：<br></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="makefile"><code><span class="code-snippet_outer"><span class="code-snippet__comment"># float(3.14)，等价于</span></span></code><code><span class="code-snippet_outer">f1 = float.__class__.__call__(float, 3.14)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 等价于</span></span></code><code><span class="code-snippet_outer">f2 = type.__call__(float, 3.14)</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">print(f1, f2)  <span class="code-snippet__comment"># 3.14 3.14</span></span></code></pre></section><p>这就是 float(3.14) 的秘密，相信<span style="color: rgb(0, 82, 255);"><strong>list</strong></span>、<span style="color: rgb(0, 82, 255);"><strong>dict</strong></span>在实例化的时候是怎么做的，你已经猜到了，做法是相同的。<br></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="go"><code><span class="code-snippet_outer"># lst = list(<span class="code-snippet__string">"abcd"</span>)</span></code><code><span class="code-snippet_outer">lst = list.__class__.__call__(list, <span class="code-snippet__string">"abcd"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">print</span>(lst)  # [<span class="code-snippet__string">'a'</span>, <span class="code-snippet__string">'b'</span>, <span class="code-snippet__string">'c'</span>, <span class="code-snippet__string">'d'</span>]</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"># dct = dict([(<span class="code-snippet__string">"name"</span>, <span class="code-snippet__string">"古明地觉"</span>), (<span class="code-snippet__string">"age"</span>, <span class="code-snippet__number">17</span>)])</span></code><code><span class="code-snippet_outer">dct = dict.__class__.__call__(dict, [(<span class="code-snippet__string">"name"</span>, <span class="code-snippet__string">"古明地觉"</span>), (<span class="code-snippet__string">"age"</span>, <span class="code-snippet__number">17</span>)])</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">print</span>(dct)  # {<span class="code-snippet__string">'name'</span>: <span class="code-snippet__string">'古明地觉'</span>, <span class="code-snippet__string">'age'</span>: <span class="code-snippet__number">17</span>}</span></code></pre></section><p>最后我们来围观一下 type_call 函数，我们说 type 的 __call__ 方法，在底层对应的是 type_call 函数，它位于<span style="color: rgb(0, 82, 255);"><strong>Object/typeobject.c</strong></span>中。</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">static</span> PyObject *</span></code><code><span class="code-snippet_outer">type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></code><code><span class="code-snippet_outer">{  </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">// 如果我们调用的是 float</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">// 那么显然这里的 type 就是 &amp;PyFloat_Type</span></span></code><code><span class="code-snippet_outer">    </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">// 这里是声明一个PyObject *</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">// 显然它是要返回的实例对象的指针</span></span></code><code><span class="code-snippet_outer">    PyObject *obj;</span></code><code><span class="code-snippet_outer">  </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">// 这里会检测 tp_new是否为空，tp_new是什么估计有人已经猜到了</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">// 我们说__call__对应底层的tp_call</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">// 显然__new__对应底层的tp_new，这里是为实例对象分配空间</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (type-&gt;tp_new == <span class="code-snippet__keyword">NULL</span>) {</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">// tp_new 是一个函数指针，指向具体的构造函数</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">// 如果 tp_new 为空，说明它没有构造函数</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">// 因此会报错，表示无法创建其实例</span></span></code><code><span class="code-snippet_outer">        PyErr_Format(PyExc_TypeError,</span></code><code><span class="code-snippet_outer">                     <span class="code-snippet__string">"cannot create '%.100s' instances"</span>,</span></code><code><span class="code-snippet_outer">                     type-&gt;tp_name);</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> <span class="code-snippet__keyword">NULL</span>;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">  </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//通过tp_new分配空间</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//此时实例对象就已经创建完毕了，这里会返回其指针</span></span></code><code><span class="code-snippet_outer">    obj = type-&gt;tp_new(type, args, kwds);</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//类型检测，暂时不用管</span></span></code><code><span class="code-snippet_outer">    obj = _Py_CheckFunctionResult((PyObject*)type, obj, <span class="code-snippet__keyword">NULL</span>);</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (obj == <span class="code-snippet__keyword">NULL</span>)</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> <span class="code-snippet__keyword">NULL</span>;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//我们说这里的参数type是类型对象，但也可以是元类</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//元类也是由PyTypeObject结构体实例化得到的</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//元类在调用的时候执行的依旧是type_call</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//所以这里是检测type指向的是不是PyType_Type</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//如果是的话，那么实例化得到的obj就不是实例对象了，而是类型对象</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//要单独检测一下</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (type == &amp;PyType_Type &amp;&amp;</span></code><code><span class="code-snippet_outer">        PyTuple_Check(args) &amp;&amp; PyTuple_GET_SIZE(args) == <span class="code-snippet__number">1</span> &amp;&amp;</span></code><code><span class="code-snippet_outer">        (kwds == <span class="code-snippet__keyword">NULL</span> ||</span></code><code><span class="code-snippet_outer">         (PyDict_Check(kwds) &amp;&amp; PyDict_GET_SIZE(kwds) == <span class="code-snippet__number">0</span>)))</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> obj;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//tp_new应该返回相应类型对象的实例对象(的指针)</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//但如果不是，就直接将这里的obj返回</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//此处这么做可能有点难理解，我们一会细说</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> obj;</span></code><code><span class="code-snippet_outer">  </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//拿到obj的类型</span></span></code><code><span class="code-snippet_outer">    type = Py_TYPE(obj);</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//执行 tp_init</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//显然这个tp_init就是__init__函数</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//这与Python中类的实例化过程是一致的。</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (type-&gt;tp_init != <span class="code-snippet__keyword">NULL</span>) {</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">//将tp_new返回的对象作为self，执行 tp_init</span></span></code><code><span class="code-snippet_outer">        int res = type-&gt;tp_init(obj, args, kwds);</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">if</span> (res &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer">            <span class="code-snippet__comment">//执行失败，将引入计数减1，然后将obj设置为NULL</span></span></code><code><span class="code-snippet_outer">            assert(PyErr_Occurred());</span></code><code><span class="code-snippet_outer">            Py_DECREF(obj);</span></code><code><span class="code-snippet_outer">            obj = <span class="code-snippet__keyword">NULL</span>;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer">            assert(!PyErr_Occurred());</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//返回obj</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> obj;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p><strong>因此从上面我们可以看到关键的部分有两个：</strong></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>调用类型对象的 tp_new 指向的函数为实例对象申请内存</p></li><li><p>调用 tp_init 指向的函数为实例对象进行初始化，也就是设置属性</p></li></ul><p><br></p><p>所以这对应Python中的<span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>和<span style="color: rgb(0, 82, 255);"><strong>__init__</strong></span>，我们说<span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>是为实例对象开辟一份内存，然后返回指向这片内存(对象)的指针，并且该指针会自动传递给<span style="color: rgb(0, 82, 255);"><strong>__init__</strong></span>中的<strong><span style="color: rgb(0, 82, 255);">self</span></strong>。</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__class"><span class="code-snippet__keyword">class</span> <span class="code-snippet__title">Girl</span>:</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">__new__</span><span class="code-snippet__params">(cls, name, age)</span>:</span></span></code><code><span class="code-snippet_outer">        print(<span class="code-snippet__string">"__new__方法执行啦"</span>)</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 写法非常固定</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 调用object.__new__(cls)就会创建Girl的实例对象</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 因此这里的cls指的就是这里的Girl，注意：一定要返回</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 因为__new__会将自己的返回值交给__init__中的self</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> object.__new__(cls)</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">__init__</span><span class="code-snippet__params">(self, name, age)</span>:</span></span></code><code><span class="code-snippet_outer">        print(<span class="code-snippet__string">"__init__方法执行啦"</span>)</span></code><code><span class="code-snippet_outer">        self.name = name</span></code><code><span class="code-snippet_outer">        self.age = age</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">g = Girl(<span class="code-snippet__string">"古明地觉"</span>, <span class="code-snippet__number">16</span>)</span></code><code><span class="code-snippet_outer">print(g.name, g.age)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__string">"""</span></span></code><code><span class="code-snippet_outer">__new__方法执行啦</span></code><code><span class="code-snippet_outer">__init__方法执行啦</span></code><code><span class="code-snippet_outer">古明地觉 16</span></code><code><span class="code-snippet_outer">"""</span></code></pre></section><p><span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>里面的参数要和<span style="color: rgb(0, 82, 255);"><strong>__init__</strong></span>里面的参数保持一致，因为我们会先执行<span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>，然后解释器会将<span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>的返回值和我们传递的参数组合起来一起传递给<strong style="color: rgb(0, 82, 255);white-space: normal;">__init__</strong>。因此<span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>里面的参数除了cls之外，一般都会写<strong>*args</strong>和<strong>**kwargs</strong>。</p><p><br></p><p>然后再回过头来看一下<span style="color: rgb(64, 118, 0);"><strong>type_call</strong></span>中的这几行代码：</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">static</span> PyObject *</span></code><code><span class="code-snippet_outer">type_call(PyTypeObject *<span class="code-snippet__keyword">type</span>, PyObject *args, PyObject *kwds)</span></code><code><span class="code-snippet_outer">{  </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//......</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//......</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), <span class="code-snippet__keyword">type</span>))</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> obj;</span></code><code><span class="code-snippet_outer">  </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//......</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//......</span></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p>我们说<span style="color: rgb(64, 118, 0);"><strong>tp_new</strong></span>应该返回该类型对象的实例对象，而且一般情况下我们是不写<span style="color: rgb(64, 118, 0);"><strong>__new__</strong></span>的，会默认执行。但是我们一旦重写了，那么必须要手动返回<strong><span style="color: rgb(123, 12, 0);">object.__new__(cls)</span></strong>。可如果我们不返回，或者返回其它的话，会怎么样呢？</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__class"><span class="code-snippet__keyword">class</span> <span class="code-snippet__title">Girl</span>:</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">__new__</span><span class="code-snippet__params">(cls, *args, **kwargs)</span>:</span></span></code><code><span class="code-snippet_outer">        print(<span class="code-snippet__string">"__new__方法执行啦"</span>)</span></code><code><span class="code-snippet_outer">        instance = object.__new__(cls)</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 打印看看instance到底是个什么东东</span></span></code><code><span class="code-snippet_outer">        print(<span class="code-snippet__string">"instance:"</span>, instance)</span></code><code><span class="code-snippet_outer">        print(<span class="code-snippet__string">"type(instance):"</span>, type(instance))</span></code><code><span class="code-snippet_outer">        </span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 正确做法是将instance返回</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment"># 但是我们不返回, 而是返回个 123</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> <span class="code-snippet__number">123</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">__init__</span><span class="code-snippet__params">(self, name, age)</span>:</span></span></code><code><span class="code-snippet_outer">        print(<span class="code-snippet__string">"__init__方法执行啦"</span>)</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">g = Girl()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__string">"""</span></span></code><code><span class="code-snippet_outer">__new__方法执行啦</span></code><code><span class="code-snippet_outer">instance: &lt;__main__.Girl object at 0x000002C0F16FA1F0&gt;</span></code><code><span class="code-snippet_outer">type(instance): &lt;class '__main__.Girl'&gt;</span></code><code><span class="code-snippet_outer">"""</span></code></pre></section><p>这里面有很多可以说的点，首先就是 __init__ 里面需要两个参数，但是我们没有传，却还不报错。原因就在于这个 __init__ 压根就没有执行，因为 __new__ 返回的不是 Girl 的实例对象。</p><p><br></p><p>通过打印 instance，我们知道了object.__new__(cls) 返回的就是 cls 的实例对象，而这里的cls就是<span style="color: rgb(0, 82, 255);"><strong>Girl</strong></span>这个类本身。我们必须要返回<strong><span style="color: rgb(0, 82, 255);">instance</span></strong>，才会执行对应的<span style="color: rgb(0, 82, 255);"><strong>__init__</strong></span>，否则<span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>直接就返回了。我们在外部来打印一下创建的实例对象吧，看看结果：</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__class"><span class="code-snippet__keyword">class</span> <span class="code-snippet__title">Girl</span>:</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">__new__</span><span class="code-snippet__params">(cls, *args, **kwargs)</span>:</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> <span class="code-snippet__number">123</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">__init__</span><span class="code-snippet__params">(self, name, age)</span>:</span></span></code><code><span class="code-snippet_outer">        print(<span class="code-snippet__string">"__init__方法执行啦"</span>)</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">g = Girl()</span></code><code><span class="code-snippet_outer">print(g, type(g))  <span class="code-snippet__comment"># 123 &lt;class 'int'&gt;</span></span></code></pre></section><p>我们看到打印的是123，所以再次总结一些<span style="color: rgb(0, 82, 255);"><strong>tp_new</strong></span>和<span style="color: rgb(0, 82, 255);"><strong>tp_init</strong></span>之间的区别，当然也对应<span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>和<span style="color: rgb(0, 82, 255);"><strong>__init__</strong></span>的区别：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>tp_new：为该类型对象的实例对象申请内存，在Python的<strong><span style="color: rgb(0, 82, 255);">__new__</span></strong>方法中通过<span style="color: rgb(0, 82, 255);"><strong>object.__new__(cls)</strong></span>的方式申请，然后将其返回</p></li><li><p>tp_init：<strong><span style="color: rgb(0, 82, 255);">tp_new</span></strong>的返回值会自动传递给<span style="color: rgb(0, 82, 255);"><strong>self</strong></span>，然后为<span style="color: rgb(0, 82, 255);"><strong>self</strong></span>绑定相应的属性，也就是进行实例对象的初始化</p></li></ul><p><br></p><p>但如果<strong><span style="color: rgb(0, 82, 255);">tp_new</span></strong>返回的不是对应类型的实例对象的指针，比如<span style="color: rgb(0, 82, 255);"><strong>type_call</strong></span>中第一个参数接收的<span style="color: rgb(0, 82, 255);"><strong>&amp;PyFloat_Type</strong></span>，但是<span style="color: rgb(0, 82, 255);"><strong>tp_new</strong></span>中返回的却是<span style="color: rgb(0, 82, 255);"><strong>PyLongObject *</strong></span>，所以此时就不会执行<span style="color: rgb(0, 82, 255);"><strong>tp_init</strong></span>。</p><p><br></p><p>以上面的代码为例，我们Girl中的<span style="color: rgb(0, 82, 255);"><strong>__new__</strong></span>应该返回<span style="color: rgb(0, 82, 255);"><strong>Girl的实例对象</strong></span>才对，但实际上返回了整型，因此类型不一致，所以不会执行<strong><span style="color: rgb(0, 82, 255);">__init__</span></strong>。</p><p><br></p><p><strong><span style="font-size: 18px;color: rgb(122, 79, 214);">下面我们可以做总结了，通过类型对象去创建实例对象的整体流程如下：</span></strong><span style="font-size: 18px;color: rgb(122, 79, 214);"></span></p><p><strong><span style="font-size: 18px;color: rgb(122, 79, 214);"><br></span></strong></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>第一步：获取类型对象的类型对象，说白了就是元类，执行元类的 tp_call 指向的函数，即 type_call</p></li><li><p>第二步：type_call 会调用该类型对象的 tp_new 指向的函数，如果 tp_new 为 NULL，那么会到 tp_base 指定的父类里面去寻找 tp_new。在新式类当中，所有的类都继承自 object，因此最终会执行 object 的 __new__。然后通过访问对应类型对象中的 tp_basicsize 信息，这个信息记录着该对象的实例对象需要占用多大的内存，继而完成申请内存的操作</p></li><li><p>调用type_new 创建完对象之后，就会进行实例对象的初始化，会将指向这片空间的指针交给 tp_init，但前提是 tp_new 返回的实例对象的类型要一致。</p></li></ul><p><br></p><p>所以都说 Python 在实例化的时候会先调用 __new__ 方法，再调用 __init__ 方法，相信你应该知道原因了，因为在源码中先调用 tp_new、再调用的 tp_init。</p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">static</span> PyObject *</span></code><code><span class="code-snippet_outer">type_call(PyTypeObject *<span class="code-snippet__keyword">type</span>, PyObject *args, PyObject *kwds)</span></code><code><span class="code-snippet_outer">{  </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//调用__new__方法， 拿到其返回值</span></span></code><code><span class="code-snippet_outer">    obj = <span class="code-snippet__keyword">type</span>-&gt;tp_new(<span class="code-snippet__keyword">type</span>, args, kwds);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (<span class="code-snippet__keyword">type</span>-&gt;tp_init != NULL) {</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">//将__new__返回的实例obj，和args、kwds组合起来</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">//一起传给 __init__</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">//其中 obj 会传给 self，</span></span></code><code><span class="code-snippet_outer">        int res = <span class="code-snippet__keyword">type</span>-&gt;tp_init(obj, args, kwds);</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">//......</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> obj;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p>所以源码层面表现出来的，和我们在 Python 层面看到的是一样的。<br></p><p><br></p><p><br></p><p style="text-align: center;"><strong style="text-align: center;white-space: normal;"><span style="font-size: 24px;color: rgb(217, 33, 66);">小结</span></strong></p><p><br></p><p>到此，我们就从 Python 和解释器两个层面了解了对象是如何调用的，更准确的说我们是从解释器的角度对 Python 层面的知识进行了验证，通过 tp_new 和 tp_init 的关系，来了解 __new__ 和 __init__ 的关系。<br></p><p><br></p><p>另外，对象调用远不止我们目前说的这么简单，更多的细节隐藏在了幕后，只不过现在没办法将其一次性全部挖掘出来。后续我们会循序渐进，一点点揭开它什么面纱，并且在这个过程中还会不断地学习到新的东西。比如说，实例对象在调用方法的时候会自动将实例本身作为参数传递给 self，那么它为什么传递呢？解释器在背后又做了什么工作呢？这些我们就以后慢慢说吧。<br></p></div>

          <script type="text/javascript" nonce="1294252622" reportloaderror>
            var first_sceen__time = (+new Date());
            if ("" == 1 && document.getElementById('js_content')) {
              document.getElementById('js_content').addEventListener("selectstart",function(e){ e.preventDefault(); });
            }
          </script>
        </div>
                        
</div>
</body>
</html>
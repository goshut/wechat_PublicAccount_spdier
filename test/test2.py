"""# coding=utf-8
图片提取测试
"""
from spider import *
from config import *
from tools import *

str1 = '''
<div id="img-content" class="rich_media_wrp">
          
          <h1 class="rich_media_title " id="activity-name">
            
《源码探秘 CPython》90. 剖析 Python 的协程
          </h1>
          <div id="meta_content" class="rich_media_meta_list">
                                      <span id="copyright_logo" class="wx_tap_link js_wx_tap_highlight rich_media_meta icon_appmsg_tag appmsg_title_tag weui-wa-hotarea">原创</span>
                                                      <span class="rich_media_meta rich_media_meta_text">
                                                                                    <span role="link" tabindex="0" id="js_author_name" class="wx_tap_link js_wx_tap_highlight rich_media_meta_link weui-wa-hotarea" datarewardsn="" datatimestamp="" datacanreward="0">古明地觉</span>
                                                                            </span>
                                      
                                                                <span class="rich_media_meta rich_media_meta_nickname" id="profileBt">
              <a href="javascript:void(0);" class="wx_tap_link js_wx_tap_highlight weui-wa-hotarea" id="js_name">
                古明地觉的编程教室              </a>
              <div id="js_profile_qrcode" aria-hidden="true" class="profile_container" style="display:none;">
                <div class="profile_inner">
                  <strong class="profile_nickname">古明地觉的编程教室</strong>
                  <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                  <p class="profile_meta">
                  <label class="profile_meta_label">微信号</label>
                  <span class="profile_meta_value">unwind_exception</span>
                  </p>

                  <p class="profile_meta">
                  <label class="profile_meta_label">功能介绍</label>
                  <span class="profile_meta_value">Python、Rust 程序猿，你感兴趣的内容我都会写，点个关注吧(#^.^#)</span>
                  </p>
                </div>
                <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                  <i class="profile_arrow arrow_out"></i>
                  <i class="profile_arrow arrow_in"></i>
                </span>
              </div>
            </span>
            <em id="publish_time" class="rich_media_meta rich_media_meta_text"></em>
            <em id="js_ip_wording_wrp" class="rich_media_meta rich_media_meta_text" role="option" style="display: none;">发表于<span id="js_ip_wording"></span></em>

          </div>

          
                                                                              <div id="js_tags" class="article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card" data-len="1" role="link" tabindex="0" aria-labelledby="js_article-tag-card__left js_a11y_comma js_article-tag-card__right">
                          
                                                <span aria-hidden="true" id="js_article-tag-card__left" class="article-tag-card__left">
                    <span class="article-tag-card__title">收录于合集</span>
                    <span class="article-tag__item-wrp no-active js_tag" data-url="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3NTczMDU2Mg==&amp;action=getalbum&amp;album_id=2206970536067497985#wechat_redirect" data-tag_id="" data-album_id="2206970536067497985" data-tag_source="4">
                      <span class="article-tag__item">#CPython源码探秘</span>
                    </span>
                  </span>
                  <span aria-hidden="true" id="js_article-tag-card__right" class="article-tag-card__right">91个</span>
                                                    </div>

          
                    
                                        

          
                    

          
                              
                                        
                    
                    
          

          
          
                                                  <div class="rich_media_content js_underline_content              " id="js_content"><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;white-space: normal;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;' data-mpa-powered-by="yiban.io"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="margin-right: -36px;outline: 0px;width: 26px;height: 55px;z-index: 1;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="2.1153846153846154" data-src="https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png" data-type="png" data-w="52" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 52px !important;"></section><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 45px;height: 45px;background: rgba(255, 238, 241, 0.56);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -12px;outline: 0px;text-align: center;visibility: visible;"><p data-mid="" style='padding-right: 12px;padding-left: 18px;outline: 0px;font-family: PingFangSC-Medium, "PingFang SC";font-weight: bold;line-height: 22px;border-bottom: 1px solid rgb(109, 85, 75);visibility: visible;'><span style="color: rgb(217, 33, 66);outline: 0px;font-size: 24px;visibility: visible;">楔子</span></p></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -8px;outline: 0px;width: 9px;height: 9px;background: rgba(255, 238, 241, 0.88);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section></section></section><p style='margin-bottom: 0em;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;white-space: normal;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><br mpa-from-tpl="t" style="outline: 0px;visibility: visible;"></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;white-space: normal;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 190px;height: 16px;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="0.08421052631578947" data-type="png" data-w="380" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 380px !important;"></section></section></section></section><p><br></p><p><span style="font-size: 15px;">了解完协程的诞生背景以及基本概念之后，我们来探究一下 Python 的协程是如何实现的。首先 Python 的协程和生成器之间有着非常紧密的联系，因此在看协程之前，强烈推荐你先看本系列的第 65 和 第 66 篇文章。</span></p><p><br></p><p><span style="font-size: 15px;">另外，关于协程的基础知识，以及 asyncio 模块的一些基本用法这里就不再赘述了，我们重点看协程的实现原理。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;"><br></span></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="margin-right: -36px;outline: 0px;width: 26px;height: 55px;z-index: 1;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="2.1153846153846154" data-src="https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png" data-type="png" data-w="52" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 52px !important;"></section><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 45px;height: 45px;background: rgba(255, 238, 241, 0.56);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -12px;outline: 0px;text-align: center;visibility: visible;"><p data-mid="" style='padding-right: 12px;padding-left: 18px;outline: 0px;font-family: PingFangSC-Medium, "PingFang SC";font-weight: bold;line-height: 22px;border-bottom: 1px solid rgb(109, 85, 75);visibility: visible;'><span style="color: rgb(217, 33, 66);outline: 0px;font-size: 24px;visibility: visible;">协程的底层结构</span></p></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -8px;outline: 0px;width: 9px;height: 9px;background: rgba(255, 238, 241, 0.88);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section></section></section><p style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><br mpa-from-tpl="t" style="outline: 0px;visibility: visible;"></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 190px;height: 16px;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="0.08421052631578947" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png" data-type="png" data-w="380" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 380px !important;"></section></section></section></section><p><span style="font-size: 15px;"><br></span><span style="font-size: 15px;">使用 async def 定义出来的函数叫协程函数，当然协程函数本质上也是一个函数。记得我们说过，函数的 __code__ 里面有一个 co_flags 字段，它可以用来判断函数的种类。</span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">pass</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">pass</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">print(func.__class__)  <span class="code-snippet__comment"># &lt;class 'function'&gt;</span></span></code><code><span class="code-snippet_outer">print(coro_func.__class__)  <span class="code-snippet__comment"># &lt;class 'function'&gt;</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 两者都是 &lt;class 'function'&gt; 类型</span></span></code><code><span class="code-snippet_outer">print(func.__code__.co_flags &amp; <span class="code-snippet__number">0x80</span>)  <span class="code-snippet__comment"># 0</span></span></code><code><span class="code-snippet_outer">print(coro_func.__code__.co_flags &amp; <span class="code-snippet__number">0x80</span>)  <span class="code-snippet__comment"># 128</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 但如果是协程函数，那么 co_flags &amp; 0x80 为真</span></span></code></pre></section><p><span style="font-size: 15px;">普通函数调用之后，会将内部的字节码全部执行完毕；协程函数调用之后，不会执行内部的字节码，而是返回一个协程对象，简称协程，协程需要扔到事件循环里面执行。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">那么下面看看协程的底层结构，开头说协程和生成器有着很紧密的联系，看完之后你就知道这个联系有多紧密了。协程对应的结构体定义在 genobject.h 中，咦，这不是生成器相关的头文件吗？</span></p><p><span style="font-size: 15px;"><br></span></p><p style="text-align: center;margin-bottom: 0em;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.8850129198966409" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFJxJTYdEpiatzaM6v5GA5ygp9OEsLJXoyjKuNDv4bMFzKUicROiaW5q54icib2yYZiaQP1zprAQ0IaMibdw/640?wx_fmt=png" data-type="png" data-w="774" style=""></p><p><span style="font-size: 15px;"></span><br></p><p><span style="font-size: 15px;">红色框框内的部分是生成器的底层结构，不要眨眼，再来看看协程的底层结构。</span></p><p><br></p><p style="text-align: center;margin-bottom: 0em;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.29423076923076924" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFJxJTYdEpiatzaM6v5GA5ygRPKCcKgicCXy4A3jsIAPp2sQibQMcS5Q88PQeXUnysyAbYic34zJekI0w/640?wx_fmt=png" data-type="png" data-w="520" style=""></p><p><span style="background-color: rgba(0, 0, 0, 0.03);font-size: 14px;"></span><br></p><p><span style="font-size: 15px;">所以我们看到所谓协程，本质上还是基于生成器实现的，只是字段名不一样。比如生成器有 gi_frame, gi_running, gi_code 等字段，协程则是 cr_frame, cr_running, cr_code。</span><br></p><p><br></p><p style="text-align: center;margin-bottom: 0em;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.8573883161512027" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFJxJTYdEpiatzaM6v5GA5ygBQ71Jw8ofzXyIEXvmDB0JVibVDFYGmzLU0MxswosHymibFTXaN21Hf4g/640?wx_fmt=png" data-type="png" data-w="582" style=""></p><p><span style="font-size: 15px;"></span><br></p><p><span style="font-size: 15px;">而且协程也有 send、close、throw 等方法，我们来对比一下生成器和协程。</span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">gen_func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">yield</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">"gen result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"coroutine result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 先来看看生成器</span></span></code><code><span class="code-snippet_outer">gen = gen_func()</span></code><code><span class="code-snippet_outer">gen.__next__()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    gen.__next__()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">except</span> StopIteration <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    print(e.value)  <span class="code-snippet__comment"># gen result</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 当生成器 return 时，会抛出一个 StopIteration</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 并将返回值设置在里面，因此 return 只是一个语法糖</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 对于协程亦是如此</span></span></code><code><span class="code-snippet_outer">coro = coro_func()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    coro.__await__().__next__()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">except</span> StopIteration <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    print(e.value)  <span class="code-snippet__comment"># coroutine result</span></span></code></pre></section><p><span style="font-size: 15px;">生成器就不说了，直接看协程。首先基于 async def 定义的协程函数，内部不可以出现 yield from，否则会出现语法错误，这是一个编译阶段就能检测出来的错误。但是出现 yield 是可以的，只不过此时就不叫协程函数了，而是叫异步生成器函数。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">而对于协程而言，只要运行一次 __next__，那么就会将内部的逻辑全部执行完。但需要注意，协程本身是没有 __next__ 方法的，它需要先调用 __await__。那么问题来了，这个 __await__ 又是什么呢？下面来解释一下。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;"><br></span></p><p><br></p><p><br></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="margin-right: -36px;outline: 0px;width: 26px;height: 55px;z-index: 1;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="2.1153846153846154" data-src="https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png" data-type="png" data-w="52" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 52px !important;"></section><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 45px;height: 45px;background: rgba(255, 238, 241, 0.56);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -12px;outline: 0px;text-align: center;visibility: visible;"><p data-mid="" style='padding-right: 12px;padding-left: 18px;outline: 0px;font-family: PingFangSC-Medium, "PingFang SC";font-weight: bold;line-height: 22px;border-bottom: 1px solid rgb(109, 85, 75);visibility: visible;'><span style="color: rgb(217, 33, 66);outline: 0px;font-size: 24px;visibility: visible;">__await__</span></p></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -8px;outline: 0px;width: 9px;height: 9px;background: rgba(255, 238, 241, 0.88);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section></section></section><p style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><br mpa-from-tpl="t" style="outline: 0px;visibility: visible;"></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 190px;height: 16px;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="0.08421052631578947" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png" data-type="png" data-w="380" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 380px !important;"></section></section></section></section><p><br></p><p><span style="font-size: 15px;">我们知道，如果想在一个协程内部驱动另一个协程执行，那么可以使用 await 关键字。</span><br></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"coroutine result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">main</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    result = <span class="code-snippet__keyword">await</span> coro_func()</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"来自 coro_func 的返回值: <span class="code-snippet__subst">{result}</span>"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    main().__await__().__next__()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">except</span> StopIteration <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    print(e)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 来自 coro_func 的返回值: coroutine result</span></span></code></pre></section><p><span style="font-size: 15px;">await 后面可以跟协程、asyncio.Task 对象、asyncio.Future 对象，而 <span style="font-size: 15px;color: rgb(2, 30, 170);">await obj </span>本质上会调用 obj 的 __await__ 方法，然后通过 __next__ 驱动执行。</span><br></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">为了更好地理解 await，我们对比一下 yield from，之前说过 yield from 可以用来实现委托生成器。<br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">gen_func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">yield</span> <span class="code-snippet__number">123</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">"result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">middle</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    res = <span class="code-snippet__keyword">yield</span> (<span class="code-snippet__keyword">yield</span> <span class="code-snippet__keyword">from</span> gen_func())</span></code><code><span class="code-snippet_outer">    print(res)</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 我们说委托生成器有一个重要的作用</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 它会在子生成器和调用方之间建立一个双向通道</span></span></code><code><span class="code-snippet_outer">g = middle()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 此时是调用方和子生成器之间直接通信</span></span></code><code><span class="code-snippet_outer">print(g.__next__())  <span class="code-snippet__comment"># 123</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 显然此时要抛异常了，那么委托生成器要负责兜底</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 会拿到子生成器的返回值，在自身内部寻找下一个 yield</span></span></code><code><span class="code-snippet_outer">print(g.__next__())  <span class="code-snippet__comment"># result</span></span></code></pre></section><p><span style="font-size: 15px;">而对于 await 也是同样的道理，它的作用和 yield from 类似。</span><br></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"coroutine result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">main</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    result = <span class="code-snippet__keyword">await</span> coro_func()</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"来自 coro_func 的返回值: <span class="code-snippet__subst">{result}</span>"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># main() 里面 await 一个子协程</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 此时 await 同样会建立一个双向通道</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 子协程会和调用方直接通信</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 另外这里的调用方可以是我们手动调用，也可以是事件循环</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 子协程要抛异常了，那么 main() 要兜底</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># await 会捕获异常，然后将返回值取出来</span></span></code><code><span class="code-snippet_outer">    main().__await__().__next__()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">except</span> StopIteration <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    print(e.value)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 来自 coro_func 的返回值: coroutine result</span></span></code></pre></section><p><span style="font-size: 15px;">我们在协程里面，可以 await 另一个协程，然后驱动它执行。等到执行完毕之后，再拿到它的返回值。或者我们还有一种写法：</span><br></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"coroutine result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">main</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">        coro_func().__await__().__next__()</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">except</span> StopIteration <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"来自 coro_func 的返回值: <span class="code-snippet__subst">{e.value}</span>"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    main().__await__().__next__()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">except</span> StopIteration <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    print(e.value)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 来自 coro_func 的返回值: coroutine result</span></span></code></pre></section><p><span style="font-size: 15px;">此时两者的做法是等价的，但很明显使用 await 要方便的多。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">另外，我们上面运行协程的时候并没有依赖事件循环，原因是协程本质上就是个生成器，即使不依赖事件循环也可以运行。当然啦，在工作中肯定还是要交给事件循环进行调度的。</span><br></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">接下来，我们通过字节码来进一步观察这背后的细节。<br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer">s = <span class="code-snippet__string">"""</span></span></code><code><span class="code-snippet_outer">async def coro_func():</span></code><code><span class="code-snippet_outer">    return f"coroutine result"</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">async def main():</span></code><code><span class="code-snippet_outer">    result = await coro_func()</span></code><code><span class="code-snippet_outer">    return f"来自 coro_func 的返回值: {result}"</span></code><code><span class="code-snippet_outer">"""</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> __name__ == <span class="code-snippet__string">'__main__'</span>:</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">import</span> dis</span></code><code><span class="code-snippet_outer">    dis.dis(compile(s, <span class="code-snippet__string">"&lt;file&gt;"</span>, <span class="code-snippet__string">"exec"</span>))</span></code></pre></section><p><span style="font-size: 15px;">先来看看模块对应的字节码：</span><br></p><p><span style="font-size: 15px;"><br></span></p><p style="text-align: center;margin-bottom: 0em;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.3919172932330827" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFJxJTYdEpiatzaM6v5GA5ygL5L24Mnd7D3eMI9MjVib9PibleF9YKBZW0kk9pGxibdUEAAibEhWsEAwBQ/640?wx_fmt=png" data-type="png" data-w="1064" style=""></p><p><span style="font-size: 15px;"></span><br></p><p><span style="font-size: 15px;">模块对应的字节码没什么好说的，我们重点看一下函数的字节码。</span><br></p><p><span style="font-size: 15px;"><br></span></p><p style="text-align: center;margin-bottom: 0em;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.977924944812362" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFJxJTYdEpiatzaM6v5GA5ygErHs9nAnMqicN0h3U4ThbrWu2iaicNsL9hUwzySYGpjLDHqap5AYnwytg/640?wx_fmt=png" data-type="png" data-w="906" style=""></p><p><span style="font-size: 15px;"></span><br></p><p><span style="font-size: 15px;">以上是两个函数的字节码，coro_func 也没什么可说的，重点是 main。</span></p><p><br></p><p><span style="font-size: 15px;">里面出现了一个指令 GET_AWAITABLE，它所做的事情就是调用协程对象的 __await__ 方法。</span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">case</span> <span class="code-snippet__title">TARGET</span>(<span class="code-snippet__params">GET_AWAITABLE</span>):</span> {</span></code><code><span class="code-snippet_outer">    PREDICTED(GET_AWAITABLE);</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//上一步的 CALL_FUNCTION 指令会构建一个协程</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//并且将协程压入到栈顶，也就是这里的iterable</span></span></code><code><span class="code-snippet_outer">    PyObject *iterable = TOP();</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//调用协程的 __await__</span></span></code><code><span class="code-snippet_outer">    PyObject *iter = _PyCoro_GetAwaitableIter(iterable);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//...</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//将 iter 设置为新的栈顶元素</span></span></code><code><span class="code-snippet_outer">    SET_TOP(iter); <span class="code-snippet__comment">/* Even if it's NULL */</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (iter == NULL) {</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">goto</span> error;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    PREDICT(LOAD_CONST);</span></code><code><span class="code-snippet_outer">    DISPATCH();</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p><span style="font-size: 15px;">所以重点是 _PyCoro_GetAwaitableIter 这个函数，我们看看协程的 __await__ 究竟返回了个啥？</span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer">PyObject *</span></code><code><span class="code-snippet_outer">_PyCoro_GetAwaitableIter(PyObject *o)</span></code><code><span class="code-snippet_outer">{</span></code><code><span class="code-snippet_outer">    unaryfunc getter = <span class="code-snippet__keyword">NULL</span>;</span></code><code><span class="code-snippet_outer">    PyTypeObject *ot;</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//如果是一个使用 async def 定义的协程</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//或者是一个被 @asyncio.coroutine 装饰的协程(不推荐)</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//那么直接返回</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (PyCoro_CheckExact(o) || gen_is_coroutine(o)) {</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">/* 'o' is a coroutine. */</span></span></code><code><span class="code-snippet_outer">        Py_INCREF(o);</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> o;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//如果不是一个协程，那么它必须实现 __await__</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//对应 tp_as_async 的 am_await 成员</span></span></code><code><span class="code-snippet_outer">    ot = Py_TYPE(o);</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (ot-&gt;tp_as_async != <span class="code-snippet__keyword">NULL</span>) {</span></code><code><span class="code-snippet_outer">        getter = ot-&gt;tp_as_async-&gt;am_await;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//如果实现了 __await__</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">if</span> (getter != <span class="code-snippet__keyword">NULL</span>) {</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__comment">//那么进行调用</span></span></code><code><span class="code-snippet_outer">        PyObject *res = (*getter)(o);</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">if</span> (res != <span class="code-snippet__keyword">NULL</span>) {</span></code><code><span class="code-snippet_outer">            <span class="code-snippet__comment">//如果一个对象不是协程，但又实现了 __await__</span></span></code><code><span class="code-snippet_outer">            <span class="code-snippet__comment">//那么 __await__ 必须返回迭代器</span></span></code><code><span class="code-snippet_outer">            <span class="code-snippet__keyword">if</span> (PyCoro_CheckExact(res) || gen_is_coroutine(res)) {</span></code><code><span class="code-snippet_outer">                <span class="code-snippet__comment">/* __await__ must return an *iterator*, not</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">                   a coroutine or another awaitable (see PEP 492) */</span></span></code><code><span class="code-snippet_outer">                PyErr_SetString(PyExc_TypeError,</span></code><code><span class="code-snippet_outer">                                <span class="code-snippet__string">"__await__() returned a coroutine"</span>);</span></code><code><span class="code-snippet_outer">                Py_CLEAR(res);</span></code><code><span class="code-snippet_outer">            } <span class="code-snippet__keyword">else</span> <span class="code-snippet__keyword">if</span> (!PyIter_Check(res)) {</span></code><code><span class="code-snippet_outer">                PyErr_Format(PyExc_TypeError,</span></code><code><span class="code-snippet_outer">                             <span class="code-snippet__string">"__await__() returned non-iterator "</span></span></code><code><span class="code-snippet_outer">                             <span class="code-snippet__string">"of type '%.100s'"</span>,</span></code><code><span class="code-snippet_outer">                             Py_TYPE(res)-&gt;tp_name);</span></code><code><span class="code-snippet_outer">                Py_CLEAR(res);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> res;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment">//否则就说明，该对象不可以被 await</span></span></code><code><span class="code-snippet_outer">    PyErr_Format(PyExc_TypeError,</span></code><code><span class="code-snippet_outer">                 <span class="code-snippet__string">"object %.100s can't be used in 'await' expression"</span>,</span></code><code><span class="code-snippet_outer">                 ot-&gt;tp_name);</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__keyword">NULL</span>;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p><span style="font-size: 15px;">关于 __await__ 必须返回迭代器，我们举个栗子：</span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__class"><span class="code-snippet__keyword">class</span> <span class="code-snippet__title">A</span>:</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">__await__</span><span class="code-snippet__params">(self)</span>:</span></span></code><code><span class="code-snippet_outer">        <span class="code-snippet__keyword">return</span> coro_func().__await__()</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"coroutine result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">main</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># A() 不是一个协程，那么它必须实现 __await__</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 并且 __await__ 里面必须返回一个迭代器</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 只有这样，才能调用 __next__ 方法</span></span></code><code><span class="code-snippet_outer">    result = <span class="code-snippet__keyword">await</span> A()</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"来自 A().__await__ 的返回值: <span class="code-snippet__subst">{result}</span>"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">try</span>:</span></code><code><span class="code-snippet_outer">    main().__await__().__next__()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">except</span> StopIteration <span class="code-snippet__keyword">as</span> e:</span></code><code><span class="code-snippet_outer">    print(e.value)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment"># 来自 A().__await__ 的返回值: coroutine result</span></span></code></pre></section><p><span style="font-size: 15px;"></span><br></p><p><span style="font-size: 15px;">然后重点来了，后面又调用了 YIELD_FROM。因为 await obj 实际上分为两步，第一步是调用 obj 的 __await__ 返回一个迭代器，由指令 <span style='white-space:pre-wrap;font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size: 14px;text-align: left;background-color: rgba(0, 0, 0, 0.03);'>GET_AWAITABLE</span> 完成；第二步是通过 __next__ 驱动执行，由指令 <span style='white-space:pre-wrap;font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size: 14px;text-align: left;background-color: rgba(0, 0, 0, 0.03);'>YIELD_FROM </span></span><span style="font-size: 15px;">完成。</span><br></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">也就是说，<span style="font-size: 15px;">obj.__awa</span><span style="font-size: 15px;">it__(</span><span style="font-size: 15px;">).</span><span style="font-size: 15px;">__next</span><span style="font-size: 15px;">__()</span><span style="font-size: 15px;"> 再加一个 StopIteration</span><span style="font-size: 15px;">异常的捕获逻辑，等价于 </span>await obj，因为 YIELD_FROM 会捕获子协程 raise 的 StopIteration。<br></span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">因此所谓的协程无非就是基于生成器进行的一个封装罢了，只是生成器既可以用作生成器本身，也可以用作协程，那么这就会出现混乱。于是 Python 在 3.5  的时候引入了 async 和 await 两个关键字，专门用于协程，但我们知道它们本质上还是基于生成器实现的即可。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;"><br></span></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="margin-right: -36px;outline: 0px;width: 26px;height: 55px;z-index: 1;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="2.1153846153846154" data-src="https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png" data-type="png" data-w="52" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 52px !important;"></section><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 45px;height: 45px;background: rgba(255, 238, 241, 0.56);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -12px;outline: 0px;text-align: center;visibility: visible;"><p data-mid="" style='padding-right: 12px;padding-left: 18px;outline: 0px;font-family: PingFangSC-Medium, "PingFang SC";font-weight: bold;line-height: 22px;border-bottom: 1px solid rgb(109, 85, 75);visibility: visible;'><span style="color: rgb(217, 33, 66);outline: 0px;font-size: 24px;visibility: visible;">通过事件循环运行协程</span></p></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -8px;outline: 0px;width: 9px;height: 9px;background: rgba(255, 238, 241, 0.88);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section></section></section><p style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><br mpa-from-tpl="t" style="outline: 0px;visibility: visible;"></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 190px;height: 16px;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="0.08421052631578947" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png" data-type="png" data-w="380" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 380px !important;"></section></section></section></section><p><br style="white-space: normal;"></p><p><span style="font-size: 15px;">虽然我们可以直接驱动协程执行，但这不是一个好的方式，协程应该放到事件循环中，由事件循环驱动执行。</span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">import</span> asyncio</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">(n)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> asyncio.sleep(n)</span></code><code><span class="code-snippet_outer">    print(<span class="code-snippet__string">f"我睡了 <span class="code-snippet__subst">{n}</span> 秒"</span>)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"coroutine result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">main</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__comment"># 基于协程创建 asyncio.Task 对象</span></span></code><code><span class="code-snippet_outer">    task1 = asyncio.create_task(coro_func(<span class="code-snippet__number">3</span>))</span></code><code><span class="code-snippet_outer">    task2 = asyncio.create_task(coro_func(<span class="code-snippet__number">1</span>))</span></code><code><span class="code-snippet_outer">    </span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> task1</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">loop = asyncio.get_event_loop()</span></code><code><span class="code-snippet_outer">loop.run_until_complete(main())</span></code><code><span class="code-snippet_outer"><span class="code-snippet__string">"""</span></span></code><code><span class="code-snippet_outer">我睡了 1 秒</span></code><code><span class="code-snippet_outer">我睡了 3 秒</span></code><code><span class="code-snippet_outer">"""</span></code></pre></section><p><span style="font-size: 15px;">这里有一个比较神奇的地方，我们明明只 await task1，但是 task2 居然也被执行了，这是什么情况。原因就在于事件循环的运行单元是 asyncio.Task 对象，当我们调用 create_task 创建 Task 对象的时候，这个 Task 对象就已经被加入到事件循环中了。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">所以此时事件循环里面有 task1 和 task2 两个任务，当我们 await task1 时，事件循环就会驱动 task1 执行。而一旦事件循环启动，那么不单单会执行 task1，而是会执行所有注册进来的任务。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">所以先打印了 </span><span style="font-size: 15px;">"我睡了 1 秒"</span><span style="font-size: 15px;">，因为该协程 sleep 的时间更短，尽管它后执行，说明在 task1 的 sleep 时发生了协程切换。</span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">import</span> asyncio</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">(n)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> asyncio.sleep(n)</span></code><code><span class="code-snippet_outer">    print(<span class="code-snippet__string">f"我睡了 <span class="code-snippet__subst">{n}</span> 秒"</span>)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">return</span> <span class="code-snippet__string">f"coroutine result"</span></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">main</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    task1 = asyncio.create_task(coro_func(<span class="code-snippet__number">3</span>))</span></code><code><span class="code-snippet_outer">    task2 = asyncio.create_task(coro_func(<span class="code-snippet__number">1</span>))</span></code><code><span class="code-snippet_outer">    task3 = coro_func(<span class="code-snippet__number">1</span>)</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> task1</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">loop = asyncio.get_event_loop()</span></code><code><span class="code-snippet_outer">loop.run_until_complete(main())</span></code><code><span class="code-snippet_outer"><span class="code-snippet__string">"""</span></span></code><code><span class="code-snippet_outer">我睡了 1 秒</span></code><code><span class="code-snippet_outer">我睡了 3 秒</span></code><code><span class="code-snippet_outer">"""</span></code></pre></section><p><span style="font-size: 15px;">还是之前的代码，但此时 task3 就没有执行，原因是它没有注册到事件循环里面。而且此时还抛出了警告，告诉我们没有 await。因为协程一旦创建了，就肯定要执行，而执行有两种方式，一种是封装成 Task 对象交给事件循环执行，另一种是直接 await。那么这两种方式有什么区别呢？</span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class="code-snippet__js" data-lang="python"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">import</span> asyncio</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">import</span> time</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">coro_func</span><span class="code-snippet__params">(n)</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> asyncio.sleep(n)</span></code><code><span class="code-snippet_outer">    print(<span class="code-snippet__string">f"我睡了 <span class="code-snippet__subst">{n}</span> 秒"</span>)</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">main1</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    task1 = asyncio.create_task(coro_func(<span class="code-snippet__number">3</span>))</span></code><code><span class="code-snippet_outer">    task2 = asyncio.create_task(coro_func(<span class="code-snippet__number">3</span>))</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> task1</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> task2</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">async</span> <span class="code-snippet__function"><span class="code-snippet__keyword">def</span> <span class="code-snippet__title">main2</span><span class="code-snippet__params">()</span>:</span></span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> coro_func(<span class="code-snippet__number">3</span>)</span></code><code><span class="code-snippet_outer">    <span class="code-snippet__keyword">await</span> coro_func(<span class="code-snippet__number">3</span>)</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">loop = asyncio.get_event_loop()</span></code><code><span class="code-snippet_outer">start = time.perf_counter()</span></code><code><span class="code-snippet_outer">loop.run_until_complete(main1())</span></code><code><span class="code-snippet_outer">print(time.perf_counter() - start)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__string">"""</span></span></code><code><span class="code-snippet_outer">我睡了 3 秒</span></code><code><span class="code-snippet_outer">我睡了 3 秒</span></code><code><span class="code-snippet_outer">3.0026131</span></code><code><span class="code-snippet_outer">"""</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">start = time.perf_counter()</span></code><code><span class="code-snippet_outer">loop.run_until_complete(main2())</span></code><code><span class="code-snippet_outer">print(time.perf_counter() - start)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__string">"""</span></span></code><code><span class="code-snippet_outer">我睡了 3 秒</span></code><code><span class="code-snippet_outer">我睡了 3 秒</span></code><code><span class="code-snippet_outer">6.0027813000000005</span></code><code><span class="code-snippet_outer">"""</span></code></pre></section><p><span style="font-size: 15px;">可以看到，执行 main1 花了 3 秒钟，但是执行 main2 花了 6 秒钟。</span></p><p><br></p><p><span style="font-size: 15px;">对于 main1 来讲，里面的协程在被包装成任务的时候，就已经注册到事件循环里面去了。驱动任何一个任务执行，均会使得事件循环里的所有任务都被执行。即使里面只有 await task1，task2 同样会被执行，只不过加上 await task2 会使得逻辑必须在 task2 完成之后才能往下走。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">对于 main2 来讲，await 后面不是 Task 对象，而是一个协程，所以此时不会进入事件循环。而是我们之前说的，像驱动生成器一样，但此时无法实现切换，两个协程串行执行。<br></span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">所以实际工作中，我们需要通过事件循环来驱动协程执行，并且好的习惯是不要直接 await 一个协程，而是要把协程封装成 Task 对象之后再 await。在 Python 里面一个协程就是调用一个原生可以挂起的函数，任务则是对协程的进一步封装，里面包含了协程在执行时的各种状态。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">而正是基于 Task 对象，我们才能够实现协程间的切换，因为它维护着协程的执行状态。而除了 Task 对象，还有一个 Future 对象，负责保存返回值。当然，由于 Task 是 Future 的子类，所以 Task 对象包含了 Future 对象的所有功能。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;">Task 和 Future 都定义在 _asynciomodule.c 中。</span></p><p><span style="font-size: 15px;"><br></span></p><p style="text-align: center;margin-bottom: 0em;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="1.480327868852459" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFJxJTYdEpiatzaM6v5GA5yghnvYuESibdes3CZITjLxoaX9OSauHh9QQ1RRkyrKw4WjjicCZic1dMcwg/640?wx_fmt=png" data-type="png" data-w="610" style=""></p><p><span style="font-size: 15px;"></span><br></p><p><span style="font-size: 15px;">asyncio 模块依赖于 _asyncio，这是一个内嵌在解释器里的模块，感兴趣的话可以去看一下。</span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;"><br></span></p><p><span style="font-size: 15px;"><br></span></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="margin-right: -36px;outline: 0px;width: 26px;height: 55px;z-index: 1;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="2.1153846153846154" data-src="https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png" data-type="png" data-w="52" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 52px !important;"></section><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 45px;height: 45px;background: rgba(255, 238, 241, 0.56);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -12px;outline: 0px;text-align: center;visibility: visible;"><p data-mid="" style='padding-right: 12px;padding-left: 18px;outline: 0px;font-family: PingFangSC-Medium, "PingFang SC";font-weight: bold;line-height: 22px;border-bottom: 1px solid rgb(109, 85, 75);visibility: visible;'><span style="color: rgb(217, 33, 66);outline: 0px;font-size: 24px;visibility: visible;">小结</span></p></section><section data-mid="" mpa-from-tpl="t" style="margin-left: -8px;outline: 0px;width: 9px;height: 9px;background: rgba(255, 238, 241, 0.88);border-radius: 50%;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section></section></section><p style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><br mpa-from-tpl="t" style="outline: 0px;visibility: visible;"></p><section data-mpa-template="t" mpa-from-tpl="t" style='margin-bottom: 0em;white-space: normal;outline: 0px;color: rgb(34, 34, 34);font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;caret-color: rgba(0, 0, 0, 0);background-color: rgb(255, 255, 255);visibility: visible;'><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;width: 578px;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;display: flex;justify-content: center;align-items: center;visibility: visible;"><section data-mid="" mpa-from-tpl="t" style="outline: 0px;width: 190px;height: 16px;visibility: visible;"><img class="rich_pages wxw-img" data-ratio="0.08421052631578947" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png" data-type="png" data-w="380" style="outline: 0px;display: block;box-sizing: border-box !important;visibility: visible !important;width: 380px !important;"></section></section></section></section><p><br></p><p><span style="font-size: 15px;">这里我们就介绍了协程的实现原理，它和生成器具有高度的相似性。当然了，我们不仅要理解协程，还要知道如何使用 asyncio 这个协程库，关于 asyncio 这里就不多说了，可以参考官方文档。</span></p><p><br></p><p><span style="font-size: 15px;">至于 _asynciomodule.c 有兴趣的话可以读一读，因为里面的内容读起来难度还是蛮大的。当然，如果能从基本概念上理解 asyncio、并且会用，也已经足够了。</span></p></div>

          <script type="text/javascript" nonce="49141431" reportloaderror>
            var first_sceen__time = (+new Date());
            if ("" == 1 && document.getElementById('js_content')) {
              document.getElementById('js_content').addEventListener("selectstart",function(e){ e.preventDefault(); });
            }
          </script>
        </div>
'''

image_xpath = '//img/@data-src'
image_xpath2 = '//img'


def image_deal():
    html_tree = etree.HTML(str1)
    image_list2 = html_tree.xpath(image_xpath2)
    # print(image_list2)
    image_list1 = html_tree.xpath(image_xpath)
    # print(image_list1)
    # 修改
    for index, i in enumerate(image_list2):
        file_name = f''
        print(i.attrib.get('data-src'))


if __name__ == '__main__':
    image_deal()
